6)Domanda:

	Si introducano le funzioni in C++ discutendone l’utilizzo e i principali elementi.
	Si discutano l’overloading delle funzioni e le funzioni template facendo degli esempi
	di definizione e invocazione delle funzioni. Si discutano i meccanismi di
	selezione delle diverse implementazioni di funzioni overloaded. Si discuta la
	differenza tra una funzione un metodo.

Risposta:
	
	Una funzione è un blocco di codice contenente dichiarazioni e istruzioni finalizzato a compiere determinate azioni. Il suo scopo è quello di favorire la modularità, il riutilizzo e la manutenzione del codice.

	Vantaggi:

	1) Modularità: il programma è scomposto in più piccole unità di elaborazione che agiscono come moduli, 			   ciascuno con il proprio scopo;

	2) Riutilizzo: ogni funzione può essere inclusa e riutilizzata in diversi programmi, con la      					   conseguente mancanza di codice duplicato.

	3) Manutenzione: in caso di un errore logico, basta andare a correggere la singola funzione per 		                 correggere il problema anche in tutti i punti in cui viene invocata.

	Le funzioni vengono dichiarate attraverso un prototipo (firma o signature) nel seguente modo:

		<tipo_ritorno> nome_funzione (parametri formali);

	Il nome della funzione è bene che sia sensato e pertinente a quanto svolto dalla funzione.
	Nel prototipo non è necessario definire anche il nome che assumeranno i parametri formali.

	La sua definizione avviene con la stessa dicitura del prototipo seguita dal blocco di codice che ne contiene l'implementazione. L'istruzione "return" serve a tornare nel punto in cui la funzione è stata invocata e porterà con se un valore che verrà assegnato al chiamante.

		<tipo_ritorno> nome_funzione (parametri formali){
			//istruzioni
		}

	Essa deve essere collocata prima di qualsiasi invocazione alla funzione nel caso un cui non venga specificato il prototipo.

	I parametri formali sono dei segna-posto che verranno implicitamente sostituiti dai parametri attuali, ovvero dai valori che verranno "passati" alla funzione con la sua invocazione, per tanto non è essenziale attribuirvi lo stesso nome dei parametri con cui verrà invocata la funzione.

	Il passaggio dei parametri può avvenire in due modi :

	- by value:	il passaggio per valore effettua una copia del valore che si vuole trasferire all'interno 				del parametro(diventa una variabile automatica pe rla funzione)

	- by reference: il passaggio per riferimento passa l'indirizzo in memoria della variabile;
					In questo modo le istruzioni all’interno di una funzione possono modificare il contenuto della variabile il cui indirizzo è stato passato alla funzione.

					Potrebbe essere necessario dover passare/restituire un array o una strutture dati pesante(matrici).
					In questi casi il passaggio by reference riduce di molto l'overhead (risorse accessorie, ma necessarie, per ottenere un determinato scopo).

-	Overloading:

	C++ consente di specificare più di una funzione con lo stesso nome (funzioni overload). Esse consentono di specificare semantiche diverse per una stessa funzione, a seconda dei tipi e del numero di argomenti. Quindi si hanno funzioni con lo stesso nome che cambiano semantica sulla base della loro firma.
	Il compilatore selezionerà la corretta versione di overloading della funzione sulla base del tipo e del numero di parametri che verranno utilizzati nell'invocazione, effettuando, ove possibile, opportune
	promozioni e conversioni di tipo.

-	Funzioni template:

	Per favorire ancora di più la riutilizzabilità del codice C++ mette a disposizione le funzioni template.
	Il template implementa il concetto di tipo parametrizzato: il tipo viene specificato come se fosse un parametro. Si indica un tipo generico T tramite la sintassi:

			template<typename T>

	o equivalentemente

			template<class T>

	Una funzione template è quindi una sorta di modello dal quale il compilatore genera opportune specializzazioni in corrispondenza di chiamate a funzione con parametri differenti(si riduce il lavoro del programmatore). Nel caso si scriva il prototipo separatamente rispetto all'implementazione, è necessario riportare il template del tipo generico anche sopra la firma.

	es.		#include<iostream>
			using namespace std;

			template<typename T>
			T sum(T a, T b);		//prototipo

			int main(){

				int a = 2;
				int b = 3;
				cout << sum(a,b) << endl;		//invocazione
			}

			template<typename T>
			T sum(T a, T b){return a+b;}		//implementazione


	Nel contesto della OOP, si incorre spesso nell'invocazione di metodi da parte di un'oggetto.
	Un metodo è un blocco di codice associato ad un'oggetto ed invocabile tramite il proprio nome.
	Nonostante le similarità, ci sono delle differenze sostanziali tra metodi e funzioni :

	1)Un metodo è definito all'interno di una classe per rendere esplicita la relazione tra classe e
	  metodo.

	2)Un metodo è in grado di operare sui contenuti della classe.

	3)La sintassi per l'invocazione di un metodo è diversa da quella di una funzione:

		obj.nome_metodo([parametri]);		//metodo

		nome_funzione([parametri[); 		//funzione




