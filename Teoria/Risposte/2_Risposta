2)Domanda:

    Si introducano i diversi tipi di dato in C++, discutendone il loro utilizzo (perché
    sono necessari? Quando è meglio preferirne uno a un altro?) e definendo come
    essi vengono rappresentati in memoria secondo lo standard IEEE.

Risposta:

    Il C++, come tutti i linguaggi di programmazione, mette a disposizione una serie di tipi di dato built-in (predefiniti) che servono all'utente per rappresentare anche tipi di dato più complessi e non primitivi, si parla infatti di tipi user-defined, quindi definiti dall'utente.

    Tipi built-in:

        - bool  1byte
        - char  1byte
        - int   4byte
        - short  2 byte
        - long   8byte
        - unsigned 4byte
        - float    4byte
        - double   8byte
        - ...

    Tipi user-defined:

        - classi
        - struct
        - ...

    Bisogna saper scegliere il tipo di dato appropriato per la rappresentazione dell'entità con cui si ha a che fare, per esempio se bisogna esprimere la propria età non ha senso utilizzare una variabile booleana o un double, perchè di certo di rappresenterà un numero intero, anzi sarebbe meglio scomodare  il tipo short, dato che ci consente di risparmiare memoria senza alcuna perdita di informazione.

    Nel calcolatore, i numeri reali sono rapprentati mediante un formato in virgola mobile.
    Si tratta di una rappresentazione in forma compatta che deriva dalla notazione scientifica.

    Lo standard IEEE-754 definisce così il formato per la rappresentazione dei numeri in virgola mobile:

        1 bit   per il SEGNO(s)
        8/11 bit    per l'ESPONENTE(E)
        23/52 bit   per la MANTISSA(M)

    N = (−1)s × 2E × M

    SEGNO:
    Si attribuisce il -1 al bit più a sinistra della codifica binaria, infatti se il primo bit è a 0
    il numero è positivo e è 1 il numero rappresentato è negativo.

    ESPONENTE:
    Si rappresenta a meno di un valore k detto di BIAS

    E = e + k

    Dove 'e' sarebbe il valore dell'esponente ottenuto dalla normalizzazione della mantissa e k è il
    valore di bias che per la rappresentazione a 32 bit vale +127

    MANTISSA:
    Si calcola la codifica binaria del numero
        ad esempio: 113.2510 diventa 1110001.01)

    Si normalizza portando la virgola a destra della prima cifra significativa del numero(sempre 1)
        ad esempio: 1110001.01 diventa 1.11000101 × 2^6

    Si rappresentano SOLO le cifre a destra della virgola fino al bit meno significativo
        ad esempio: sarà M = 11000101_000000000000000

    Con 8 bit è possibile rappresentare tutti i valori da -126 a 127

    Esempio:

        113.2510 = 1110001.012 = 1.11000101 × 26
        Quindi e = 6
        Allora E = 6 + k = 6 + 127 = 133 = 10100001
        Infine, il segno: dato che il numero −113.25 è negativo, s=1

        Quindi la codifica a 32 bit floating point IEEE 754 del numero −113.25 è la seguente:

        | 1 | 10100001 | 11000101000000000000000 |
          s      E                M

    Limiti:
        #include<climits>
        ...
        cout << INT_MIN << endl;
